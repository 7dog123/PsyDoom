#include "ExeFile.h"
#include "FatalErrors.h"
#include "FileUtils.h"
#include "FuncSignature.h"
#include "PrintUtils.h"
#include "TextIStream.h"
#include <fstream>

//----------------------------------------------------------------------------------------------------------------------
// Entry point for 'PSXExeSigMatcher'
//----------------------------------------------------------------------------------------------------------------------
// Program purpose:
//
//  Parses the PSX function signatures generated by 'PSXObjSigGen' and attempts to match those against code in a
//  specified .EXE file. Outputs a list of potential matches to the specified file.
//----------------------------------------------------------------------------------------------------------------------

int main(int argc, char* argv[]) noexcept {
    if (argc != 4) {
        FATAL_ERROR_F("Usage: %s <INPUT_SIGNATURES_FILE> <INPUT_EXE_FILE> <OUTPUT_MATCHES_FILE>\n", argv[0]);
    }

    // Read the function signatures file generated by the other tool previously mentioned
    std::vector<FuncSignature> funcSigs;

    try {
        std::string sigsFileStr;

        if (!FileUtils::readFileAsString(argv[1], sigsFileStr)) {
            FATAL_ERROR_F("Failed to read input file '%s'!\n", argv[1]);
        }

        TextIStream textStream(sigsFileStr.c_str(), (uint32_t) sigsFileStr.size());
        FuncSignatureUtils::readSigsFromTextStream(textStream, funcSigs);
    } catch (...) {
        FATAL_ERROR_F("An error occurred while parsing function signatures from input file '%s'!\n", argv[1]);
    }

    // Read the exe file
    ExeFile exe;
    exe.loadFromFile(argv[2]);

    // Decode all instructions in the exe
    const uint32_t numExeWords = exe.sizeInWords;
    std::vector<CpuInstruction> exeInstructions;
    exeInstructions.reserve(numExeWords);

    for (uint32_t wordIdx = 0; wordIdx < numExeWords; ++wordIdx) {
        CpuInstruction instruction;
        instruction.decode(exe.words[wordIdx].value);
        exeInstructions.push_back(instruction);
    }

    // Do brute force matching!
    // Not a very smart way of doing things, but gets the job done.
    try {
        std::fstream out;
        out.open(argv[3], std::fstream::out);

        for (const FuncSignature& sig : funcSigs) {
            std::printf("Search for matches for '%s'...\n", sig.name.c_str());
            const uint32_t numSigWords = (uint32_t) sig.instructions.size();

            for (uint32_t startExeWordIdx = 0; startExeWordIdx < numExeWords; ++startExeWordIdx) {
                // Are there enough words left in the exe for a match?
                if (startExeWordIdx + numSigWords > numExeWords)
                    break;

                // Check if all instructions match, taking into account wildcard instructions.
                // Wildcard instructions match only on instruction type!
                bool bMatch = true;

                for (uint32_t sigWordIdx = 0; sigWordIdx < numSigWords; ++sigWordIdx) {
                    const CpuInstruction& i1 = exeInstructions[startExeWordIdx + sigWordIdx];
                    const CpuInstruction& i2 = sig.instructions[sigWordIdx];

                    if (i1 != i2) {
                        if ((i1.opcode != i2.opcode) || (!sig.bInstructionIsPatched[sigWordIdx])) {
                            bMatch = false;
                            break;
                        }
                    }
                }

                // Did we find a match? If so then output it!
                if (bMatch) {
                    const uint32_t addr = exe.baseAddress + startExeWordIdx * 4;
                    PrintUtils::printHexU32(addr, true, out);
                    out << " matches function '";
                    out << sig.name;
                    out << "'\n";
                }
            }
        }
    } catch (...) {
        FATAL_ERROR_F("An error occurred while outputting to file '%s'!\n", argv[3]);
    }

    return 0;
}
