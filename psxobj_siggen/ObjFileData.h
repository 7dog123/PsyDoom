#pragma once

//----------------------------------------------------------------------------------------------------------------------
// Data structures describing a parsed .OBJ file dump generated by 'DUMPOBJ.EXE'.
// Describe the contents of the OBJ file.
//----------------------------------------------------------------------------------------------------------------------
#include <cstddef>
#include <cstdint>
#include <string>
#include <vector>

// Represents a section type in the OBJ file
enum class SectionType : uint16_t {
    RDATA,      // Read only data
    TEXT,       // Code
    DATA,       // Writable data
    SDATA,      // Writable data addressable as an offset to '$gp'
    SBSS,       // Non explicitly initialized data, addressable as an offset to '$gp'
    BSS,        // Non explicitly initialized data
    CTORS,      // Module initialization functions
    DTORS       // Module tear down functions
};

// Represents a patch applied to a piece of code or data.
// I don't put much effort into interpreting these fields however, other than using the target offset
// to figure out which instructions to mark as 'wildcards' in pattern matching.
struct Patch {
    static constexpr uint16_t NO_SOURCE_SECTION = 0xFFFFu;
    static constexpr uint32_t NO_SOURCE_SYMBOL = 0xFFFFFFFFu;

    uint16_t    type;
    uint16_t    sourceSection;      // 'NO_SOURCE_SECTION' if none
    uint32_t    sourceSymbol;       // 'NO_SOURCE_SYMBOL' if none
    uint32_t    sourceOffset;
    uint32_t    targetOffset;
};

// Represents a section of a particular type in the object file.
// The section can contain code or data and any number of patches applied at link time.
struct Section {
    static constexpr uint16_t MAX_SECTION_NUMBER = 0xFFFEu;
    
    uint16_t                    number;
    SectionType                 type;
    uint16_t                    alignment;
    uint16_t                    group;
    std::vector<std::byte>      data;
    std::vector<Patch>          patches;
};

// Represents a symbol defined in the object file.
// The symbol can be defined within a section in the object file, or externally defined.
struct Symbol {
    static constexpr uint32_t EXTERNAL_SECTION = 0xFFFFFFFFu;
    static constexpr uint32_t EXTERNAL_OFFSET = 0xFFFFFFFFu;

    uint32_t        number;
    uint32_t        defSection;     // 'EXTERNAL_SECTION' if externally defined
    uint32_t        defOffset;      // 'EXTERNAL_OFFSET' if externally defined
    std::string     name;
};

// Container for the entire object file.
// Contains all of the sections and symbols defined in the object file.
struct ObjFile {
    std::vector<Section>    sections;
    std::vector<Symbol>     symbols;
    uint16_t                curSectionNumber;
    uint16_t                lnkVersion;             // Should be '2'
    uint16_t                processorType;          // Should be '7' for MIPS
    uint16_t                fileNumber;
    std::string             fileName;
};
